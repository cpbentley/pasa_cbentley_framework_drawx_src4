/*
 * (c) 2018-2020 Charles-Philip Bentley
 * This code is licensed under MIT license (see LICENSE.txt for details)
 */
package pasa.cbentley.framework.drawx.src4.string;

import java.util.Enumeration;

import pasa.cbentley.byteobjects.src4.core.ByteObject;
import pasa.cbentley.byteobjects.src4.utils.ByteObjectUtilz;
import pasa.cbentley.core.src4.helpers.BytesIterator;
import pasa.cbentley.core.src4.helpers.StringBBuilder;
import pasa.cbentley.core.src4.logging.Dctx;
import pasa.cbentley.core.src4.logging.IStringable;
import pasa.cbentley.core.src4.structs.IntBuffer;
import pasa.cbentley.core.src4.structs.IntInterval;
import pasa.cbentley.core.src4.structs.IntIntervals;
import pasa.cbentley.core.src4.structs.IntToStrings;
import pasa.cbentley.core.src4.utils.BitUtils;
import pasa.cbentley.core.src4.utils.CharUtils;
import pasa.cbentley.core.src4.utils.ColorUtils;
import pasa.cbentley.framework.coredraw.src4.ctx.IFlagToStringCoreDraw;
import pasa.cbentley.framework.coredraw.src4.interfaces.IMFont;
import pasa.cbentley.framework.drawx.src4.ctx.DrwCtx;
import pasa.cbentley.framework.drawx.src4.ctx.IBOTypesDrw;
import pasa.cbentley.framework.drawx.src4.ctx.ObjectDrw;
import pasa.cbentley.framework.drawx.src4.ctx.ToStringStaticDrawx;
import pasa.cbentley.framework.drawx.src4.engine.GraphicsX;
import pasa.cbentley.framework.drawx.src4.engine.RgbImage;
import pasa.cbentley.framework.drawx.src4.tech.ITechAnchor;
import pasa.cbentley.framework.drawx.src4.tech.ITechFigure;

/**
 * Tracks the metering and drawing of a String of characters.
 * <br>
 * <br>
 * Provides access to character positions with the class {@link StringMetrics}. This allow the editing module
 * to position the caret at any characters.
 * <br>
 * <br>
 * Initialized with {@link Stringer#initFig(ByteObject, String)}
 * {@link Stringer#initTextEffects(ByteObject, ByteObject[])}
 *  Stuff used by both drawing and metrics.
 * <br>
 * <br>
 * Optimization. Buffer for String Editing.
 * <br>
 * <br>
 * <b>String selection</b>
 * <br>
 * <br>
 * String selection is implemented with an interval which is rendered using an additional Text Fx.
 * and setting interval {@link Stringer#setInterval(int, int)}
 * <br>
 * <br>
 * Selection style will override some of the underlying style, like the foreground color and background color.
 * Like in Eclipse, it may decide to key the font and the face.
 * <br>
 * How  do you defined 10 different style of fx assigned by order or randomly to each character of a word?
 * The root fx defines 10 sub object of type {@link IDrwTypes#TYPE_050_FIGURE}
 * <br>
 * <br>
 * @see StringFx
 * @see StringMetrics
 * @see IBOFxStr
 * <br>
 * <br>
 * 
 * @author Charles-Philip Bentley
 *
 */
public class Stringer extends ObjectDrw implements IStringable, ITechFigure, IBOTypesDrw, IBOFxStr {

   /**
    * 
    * {@link ITechAnchor}
    * 
    * Anchors the String figure in the box defined by the Stringer area.
    * <br>
    * However String have a locale associated with it.
    * Therefore the String is a 
    * <li> Bidi (bi directional) texts also are a challenge
    * <li>dextrosinistral text
    * <li>sinistrodextral text from the left to the right
    */
   ByteObject             anchor;

   /**
    * Used for alignment
    */
   int                    areaH;

   /**
    * Used for alignment
    */
   int                    areaW;

   /**
    * the x coordinate at which the draw the String.
    * <br>
    * <br>
    * When drawing shapes on a {@link RgbImage} for mask, this value is not used
    */
   int                    areaX;

   int                    areaY;

   int                    breakH;

   private int            breakMaxLines;

   /**
    * 
    */
   private int            breakType;

   int                    breakW;

   /**
    * When many different styles are used at the character level, the synthesis of merges is set here.
    * <br>
    * <br>
    * The merge is done for line-word-char.
    * <br>
    * <br>
    * Therefore char specific fx will always be highest priority.
    * <br>
    * <br>
    * 
    * TODO specific charfxs are set by BO using intervals and layers
    */
   StringFx[]             charFxs;

   /**
    * Modified when Trimming. Thus the word Charles trimmed at letter 5 will be Cha..
    * <br>
    * <br>
    * This char array is fully controlled. While source char array may be from a bigger source.
    * <br>
    * What happens when the chars include the .. of a trim cue?
    * 
    * " " spaces when text is justified
    * 
    * "\" character for image/figure area
    * 
    * " " space for holes generated by figures
    * 
    * When markup/markdown text is read, it must be interpreted, generating stytle intervals.
    * <br>
    * 
    * "Markdown is a text-to-HTML conversion tool for web writers"
    * 
    * 
    */
   char[]                 chars;

   StringBBuilder         buffer;

   /**
    * Stores original string before trimming and imageing
    * 
    * A figure/image is considered like a single character at its anchor
    * 
    * \img{$1} the second image in the table, height is 1 line, width is ratio sized
    * \img{$1} when no width.. it takes the size of one _ when no height, 1 line
    * \img{tree.png} 
    * \fig{$0} 0 index figure , color is font color
    * 
    * replace image area with special character. Paint
    * 
    */
   char[]                 charsBackup;

   /**
    * <li> {@link ITechStringer#TYPE_0_SINGLE_LINE}
    * <li> {@link ITechStringer#TYPE_1_SINGLE_LINE_FX}
    * <li> {@link ITechStringer#TYPE_2_BREAKS}
    * <li> {@link ITechStringer#TYPE_3_BREAKS_FX}
    * <li> {@link ITechStringer#TYPE_7_LINE_BREAKS_WORD_BREAKS_FX}
    */
   int                    drawLineType;

   int                    drawWordType;

   /**
    * Definition of dynamic fxs.
    */
   ByteObject[]           fxsDynamicDefinition;

   /**
    * Array for the static fx that will be applied to characters/words using the rule based system for deciding 
    * on what index a given static style is applied.
    * <br>
    * <br>
    * <li>{@link IBOFxStr#FX_OFFSET_04_INDEX2}
    * <li>{@link IBOFxStr#FX_OFFSET_05_INDEX_PATTERN1}
    * <br>
    * <br>
    * Array never contains nulls.
    * <br>
    * <br>
    * Static Fx applies to the same
    * 
    * Used for first and last letters fx.
    * 
    * Or doing 1 2 3, 1 2 3 patterns.
    * 
    * <br>
    * Example: String with text effect for the first letter of each word of at least 2 alphanumerical letters
    */
   StringFx[]             fxsStatic;

   private StringFx[]     fxsStaticIndex;

   /**
    * Tracks the intervals for the Dynamic Styles.
    * <br>
    * {@link IDrwTypes#TYPE_070_TEXT_EFFECTS} already affecting an index will merge with the dynamic style.
    * <br>
    * <br>
    * By Default Dynamic text effect merges over, which means it replaces static style definitions
    * <br>
    * Created on demand. So by default extra fxs are not loaded since most String items will use only the default
    * styling until the user makes an action to modify.
    * <br>
    */
   StringInterval[]       intervals;

   /**
    * not null.
    */
   StringLayerStyle[]     styleLayers;

   /**
    * Layers generated by {@link ByteObject} fx definitions.
    * Applied BEFORE any dynamic style. They belong to the root style.
    * For example, first letter of each word kind of style.
    * Style for punctuation. {@link IBOFxStrChar#FXCHAR_FLAG_1_CHARS_BASED}
    * Style for some characters.. {@link IBOFxStrChar#FXCHAR_FLAG_1_CHARS_BASED}
    */
   StringLayerStyle[]     styleLayersBO;

   //IntBuffer[]            intervals;

   /**
    * the length of characters starting offsetChars.
    */
   int                    lengthChars;

   /**
    * When specific line fxs are used.
    * 
    * Those {@link StringFx} are applied to all lines. 
    */
   StringFx[]             lineFxs;

   /**
    * Absolute offset for reading characters in the character array.
    */
   int                    offsetChars;

   /**
    * Provides the {@link Stringer} with easily accessible state information.
    * <br>
    * <br>
    * <li> {@link ITechStringer#STATE_04_TRIMMED}
    */
   private int            states;

   /**
    * The {@link StringDraw} based on areaX and areaY.
    */
   StringDraw             stringDraw;

   /**
    * Global Text effects definition. Never null. First it is the translation of String figure values.
    * <br>
    * Then it is merged with generic fx fields . char mask.
    * <br>
    * i.e a line fx that applies to all lines is stored here.
    * <br>
    * 
    * The {@link StringFx} define alternate {@link StringFx} which are used based on index or an interval
    * <br>
    * <br>
    * 
    */
   StringFx               stringFx;

   StringMetrics          stringMetrics;

   /**
    * 
    */
   int[]                  styleFlags;

   /**
    * Text figure
    * TYPE_050_FIGURE
    */
   ByteObject             text;

   /**
    * Active interval
    */
   private StringInterval currentInterval;

   /**
    * Draw a debug rectangle around the area
    */
   private boolean        toStringDebugArea;

   /**
    * 
    * @param drc
    */
   public Stringer(DrwCtx drc) {
      super(drc);
      stringMetrics = new StringMetrics(drc, this);
      stringFx = new StringFx(drc, this);
      stringDraw = new StringDraw(drc, this);
   }

   /**
    * Appends Characters at the end of the buffer using the current style
    * 
    * We can know if a newline/break occurs.
    * if not, no need to compute breask again.
    * @param c
    */
   public void addChar(char c) {
      chars = drc.getUCtx().getMem().increaseCapacity(chars, 3);
      int index = offsetChars + lengthChars;
      chars[index] = c;
      stringMetrics.addChar(index, c);
      lengthChars++;
   }

   /**
    * Insert c at index
    * @param c
    * @param index
    */
   public void addChar(char c, int index) {

   }

   public char[] getCharsRef() {
      return chars;
   }

   /**
    * Called by client when he wants to modify the string
    * <br>
    * Updates the breaks
    * <br>
    * To initialize Stringer with a string,
    * <br>
    * @param cs update char array
    * @param index
    * @param c
    */
   public void addChar(char[] cs, int index, char c) {
      chars = cs;
      stringMetrics.addChar(index, c);
      lengthChars++;
   }

   /**
    * Only works if figure has its own text.
    * @param textFigure
    */
   public void append(ByteObject textFigure) {
      this.append(textFigure, null);
   }

   /**
    * 
    * @param textFigure
    * @param fx
    */
   public void append(ByteObject textFigure, ByteObject fx) {
      // TODO Auto-generated method stub

   }

   private void checkStateRun() {
      if (text == null) {
         throw new IllegalStateException("No Text Figure Set");
      }
   }

   /**
    * 
    * @param cs
    * @param indexRelative
    */
   public synchronized void deleteCharAt(char[] cs, int indexRelative) {
      chars = cs;
      //metrics uses the previous len value
      stringMetrics.deleteCharAt(indexRelative);
      lengthChars--;
   }

   /**
    * Entry point but draws all the characters
    * <br>
    * <br>
    * X and Y positions are the ones currently set at the {@link StringDraw} tracker.
    * <br>
    * <br>
    * Metrics have been initialized? If String hasn't been broken, everything is drawn on one line.
    * <br>
    * <br>
    * 
    * @param g
    */
   public void draw(GraphicsX g) {
      if (ToStringIsDebugArea()) {
         g.setColor(ColorUtils.FULLY_OPAQUE_RED);
         g.drawRect(areaX - 1, areaY - 1, areaW + 1, areaH + 1);
      }
      if (stringFx.scale != null) {
         drawScaled(g);
      } else {
         drawOffsets(g, areaX, areaY, 0, lengthChars, 0, stringMetrics.getNumOfLines());
      }
      //System.out.println(this.toString());
   }

   /**
    * Draw the given character index from (x,y) position last given 
    * <br>
    * <br>
    * Used cached instance.
    * Draws any charFx of this line.
    * <br>
    * What about Line FXs?
    * <br>
    * <br>
    * Called by user of {@link Stringer} when a specific character needs to be drawn again.
    * <br>
    * <br>
    * 
    * @param g
    * @param caretIndex
    */
   public void drawChar(GraphicsX g, int indexRelative) {
      if (hasState(ITechStringer.STATE_01_CHAR_EFFECTS)) {
         getDraw().drawCharFx(g, chars[offsetChars + indexRelative], indexRelative);
      } else {
         getDraw().drawChar(g, chars[offsetChars + indexRelative], indexRelative);
      }
   }

   /**
    * 
    * Entry point for the {@link StringDrawable} draw content method to paint parts of the String on {@link GraphicsX}.
    * <br>
    * <br>
    * Draws the desired lines and characters specified by the scrolling offsets.
    * It tries to honour the offset. Line offsets are meaningless if there is one line.
    * <br>
    * <br>
    * This is fine for line {@link StringFx} but what happens to Paragraph or {@link IBOFxStr#FX_SCOPE_4_TEXT}
    * when a line is drawn again?
    * <br>
    * <br>
    * {@link StringFx} global graphical artifacts must be drawn again.
    * <br>
    * <br>
    * Imagine a line fx artifact that draws a figure at the start of a line and another figure at the end of
    * a line. It is not a global artifact, but a position sensivite one which means when the line
    * width changes, those artifacts must be drawn again.
    * <br>
    * <br>
    * Uses a shift to get the correct x,y
    * @param g
    * @param x root x coordinate on {@link GraphicsX} may change from init value for the purpose of mask/scaling
    * @param y root y coordinate
    * @param wOffset start character index. Scrolling related. Default:0 
    * @param wNum number of characters to draw. Default: len of characters. A bigger value will scale back to the maximum possible.
    * @param hOffset start line offset. Default:0
    * @param hNum number of lines. Default:1
    * <br>
    * <br>
    * 
    */
   public void drawOffsets(GraphicsX g, int x, int y, int wOffset, int wNum, int hOffset, int hNum) {
      //System.out.println("#Stringer#draw at " + x + "," + y);
      StringDraw stringDraw = getDraw();
      if (x != areaX || y != areaY) {
         stringDraw = new StringDraw(drc, this);
         stringDraw.init(x, y);
      }
      int[] breaks = stringMetrics.breaks;
      if (breaks == null) {
         //draw everything on a single line
         int offset = this.offsetChars + wOffset;
         int len = Math.min(wNum, this.lengthChars);

         stringDraw.drawLine(g, offset, len, 0);

      } else {
         int numLines = stringMetrics.getNumOfLines();
         int end = Math.min(numLines, hNum);
         int firstLineIndex = hOffset;
         //
         if (wOffset != 0 || hOffset != 0) {
            stringDraw = new StringDraw(drc, this);
            int dx = x;
            int dy = y;
            if (wOffset > 0) {
               dx -= stringMetrics.getCharX(wOffset);
            }
            if (hOffset > 0) {
               dy -= getLineY(firstLineIndex);
            }
            stringDraw.init(dx, dy);
         }
         for (int i = 0; i < end; i++) {
            int lineIndex = hOffset + i;
            int index = ITechStringer.BREAK_HEADER_SIZE + (i + hOffset) * ITechStringer.BREAK_WINDOW_SIZE;
            int startOffset = breaks[index];
            int charNum = breaks[index + 1];
            //wOffset decides what to draw
            int len = Math.min(wNum, charNum);
            stringDraw.drawLine(g, startOffset + wOffset, len, lineIndex);
         }
      }
   }

   public void drawScaled(GraphicsX g) {
      int bgColor = 0;
      if (g.isVirgin(areaX, areaY, areaW, areaH)) {
         bgColor = g.getBgColor();

      } else {
         //we must use a color not used
         bgColor = 0;

         //or we can use the background color of hosting figure in StringDrawable.
      }
      int scaledImageW = stringMetrics.getPrefWidth() + 1;
      int scaledImageH = stringMetrics.getPrefHeight() + 1;
      //draw on image and scale to fit area. metrics
      //TODO check if figure has defined a bgcolor else use transparent
      RgbImage baseImage = drc.getCache().create(scaledImageW, scaledImageH, bgColor);
      GraphicsX gi = baseImage.getGraphicsX();
      int scalePosX = 1; //glitch needed for pretty scaling.
      int scalePoxY = 0;
      drawOffsets(gi, scalePosX, scalePoxY, 0, lengthChars, 0, stringMetrics.getNumOfLines());

      //removes background pixels if the x,y area is not virgin of background color

      //TODO fix the double blending
      RgbImage scaledImage = drc.getRgbImageOperator().scaleRgbImage(baseImage, areaW, areaH, stringFx.scale);

      g.drawRgbImage(scaledImage, areaX, areaY);
      baseImage.dispose();
      scaledImage.dispose();
   }

   public StringInterval[] ensureCapacity(StringInterval[] ar, int val) {
      if (ar == null) {
         return new StringInterval[val + 1];
      }
      if (ar.length <= val) {
         StringInterval[] newa = new StringInterval[val + 1];
         for (int i = 0; i < ar.length; i++) {
            newa[i] = ar[i];
         }
         return newa;
      }
      return ar;
   }

   /**
    * Trim the {@link Stringer}, that is reduces the len field to number of characters.
    * <br>
    * Replaces some characters with Trim cue '.'
    * <li> P..
    * <li> ..
    * <li> .
    * <br>
    * <br>
    * <br>
    * One or two character words are not trimmed.
    * <br>
    * <br>
    * You cannot trim a logical init of -1 -2 -x.
    * <br> 
    * @param lastIndex the last absolute index at which the string should end. cannot be smaller than Stringer offset.
    */
   public void executeTrim(int lastIndex) {
      if (lastIndex < offsetChars) {
         throw new IllegalArgumentException("" + lastIndex);
      }
      if (lengthChars <= 2) {
         return;
      }
      setState(ITechStringer.STATE_04_TRIMMED, true);
      charsBackup = chars;
      int numChars = lastIndex - offsetChars;
      chars = new char[numChars];
      if (numChars <= 0) {
         lengthChars = 0;
      } else if (numChars <= 1) {
         lengthChars = 1;
         chars[offsetChars] = '.';
      } else {
         int fin = 0;
         lengthChars = numChars;
         fin = lastIndex - 2;
         for (int i = 0; i < fin; i++) {
            chars[i] = charsBackup[i];
         }
         chars[fin] = '.';
         chars[fin + 1] = '.';
      }
   }

   public int getBreakH() {
      return breakH;
   }

   public int getBreakMaxLines() {
      return breakMaxLines;
   }

   public int getBreakType() {
      return breakType;
   }

   public int getBreakW() {
      return breakW;
   }

   public char getCharAtRelative(int indexRel) {
      return chars[offsetChars + indexRel];
   }

   /**
    * Return the leave on the given index
    * 
    * @param index
    * @return
    */
   public StringLeaf getLeafFor(int index) {
      for (int i = 0; i < leaves.length; i++) {
         if (leaves[i].contains(index)) {
            return leaves[i];
         }
      }
      return null;
   }

   /**
    * Returns the {@link StringFx} used to draw the character at index
    * <br>
    * <br>
    * TODO how to code for a character color on each line from a color function? is this a leaf for each line?
    * <br>
    * Yes it is a leaf one each line.
    * <br>
    * This method is used by {@link StringMetrics#getCharWidthCompute(char, int)} when breaking down the String.
    * 
    * As a consequence LineFx does not impact string breaking ?
    * 
    * @param index
    */
   public StringFx getCharFx(int index) {
      //there is at least the base interval
      IntInterval owner = intervalOfStringLeaves.getIntervalIntersect(index);
      if (owner == null) {
         throw new IllegalStateException();
      }

      StringLeaf leaf = (StringLeaf) owner.getPayload();

      return leaf.getFx();
   }

   /**
    * Return the deepest {@link StringInterval} for the given index.
    * <br>
    * <br>
    * @param index
    * @return {@link StringInterval} or null if index out of bounds
    */
   public StringInterval getInternalFromIndex(int index) {
      for (int i = 0; i < intervals.length; i++) {
         StringInterval ib = intervals[i];
         if (ib.isInside(index)) {
            return ib;
         }
      }
      return null;
   }

   public int getCharsStart() {
      return offsetChars;
   }

   /**
    * Reset states.
    * @param sb
    */
   public void setSource(StringBBuilder sb) {
      this.buffer = sb;
      resetState();
   }

   /**
    * Returns a copy of the displayed string, including special characters
    * @return
    */
   public String getDisplayedString() {
      if (chars == null) {
         return "";
      }
      return new String(chars, offsetChars, lengthChars);
   }

   public StringDraw getDraw() {
      return stringDraw;
   }

   /**
    * <li> {@link ITechStringer#TYPE_0_SINGLE_LINE}
    * <li> {@link ITechStringer#TYPE_1_SINGLE_LINE_FX}
    * <li> {@link ITechStringer#TYPE_2_BREAKS}
    * <li> {@link ITechStringer#TYPE_3_BREAKS_FX}
    * <li> {@link ITechStringer#TYPE_7_LINE_BREAKS_WORD_BREAKS_FX}
    * @return
    */
   public int getDrawType() {
      return drawLineType;
   }

   /**
    * The base {@link StringFx} for the whole string.
    * @return
    */
   public StringFx getFx() {
      //#debug
      drc.toStringCheckNull(stringFx);
      return stringFx;
   }

   /**
    * Returns an {@link IntBuffer} containing the intervals using the given text effect id.
    * <br>
    * <br>
    * 
    * @param intervalId
    * @return
    */
   public StringInterval getInterval(int intervalId) {
      if (intervals != null) {
         return intervals[intervalId];
      } else {
         return null;
      }
   }

   public int getLen() {
      return lengthChars;
   }

   /**
    * Returns the root {@link StringFx} for the given line.
    * <br>
    * <br>
    * Returns the default.
    * 
    * @param i
    * @return
    */
   public StringFx getLineFx(int i) {

      return stringFx;
   }

   public int getLineY(int i) {
      return stringMetrics.lineYs[i];
   }

   public StringMetrics getMetrics() {
      return stringMetrics;
   }

   /**
    * Number of 
    * @param textFigure
    * @return
    */
   int getNumDynamic(ByteObject textFigure) {
      ByteObject[] subs = textFigure.getSubs(TYPE_070_TEXT_EFFECTS);
      int count = 0;
      if (subs != null) {
         for (int i = 0; i < subs.length; i++) {
            if (subs[i] != null && subs[i].hasFlag(FX_OFFSET_02_FLAGX, FX_FLAGX_2_DYNAMIC)) {
               count++;
            }
         }
      }
      return count;
   }

   /**
    * 
    * @return
    */
   public int getNumOfLines() {
      return stringMetrics.getNumOfLines();
   }

   int getNumStaticIndex(ByteObject[] subs) {
      int count = 0;
      for (int i = 0; i < subs.length; i++) {
         if (subs[i] != null && !subs[i].hasFlag(FX_OFFSET_02_FLAGX, FX_FLAGX_2_DYNAMIC)) {
            if (subs[i].hasFlag(FX_OFFSET_02_FLAGX, FX_FLAGX_6_DEFINED_INDEX)) {
               count++;
            }
         }
      }
      return count;
   }

   /**
    * The base {@link StringFx} for the whole string.
    * @return
    */
   public StringFx getStringFx() {
      return stringFx;
   }

   /**
    * Format String to fit into the <code>width</code> parameter given the {@link Font}.
    * <br>
    * <br>
    * Does not modify the state of the {@link Stringer}.
    * <br>
    * <br>
    * 
    * When maxLines is 1, trim as soon as width is consumed.
    * <br>
    * When maxLines is 2, trim on the second line after a line break.
    * <br>
    * <br>
    * <b>Structure of Integer Array</b> <br>
    * index[0] = control value<br>
    * index[1] = start index of 1st line<br>
    * index[2] = number of characters on 1st line<br>
    * index[3] = start index of 2nd line<br>
    * index[4] = number of characters on 2nd line<br>
    * <br>
    * This structure allows to skip newline entirely. It allows to draw tabs \t.
    * 
    * <li>array's length is the number of lines * 2 + 1
    * <li>The first value is a control value.
    * <li>A line may be empty.
    * <br>
    * <br>
    * TODO Write a switch to stop the format for really big strings. The maxline is a first security.                 
    * <br>
    * <br>
    * @param width width given for formatting the string. If width not big enough for one character. Method fits at least one letter by line.
    * @param maxLines the number of lines after -1 if infinity of lines. Automatically sets the TRIM state to the 
    * @return integer array 
    */
   public int[] getTrimFormat(int width, int maxLines) {
      int lineWidth = 0;
      int lineCount = 1;
      int numCharOnLine = 0;
      IntBuffer data = new IntBuffer(drc.getUCtx());
      StringMetrics sm = this.getMetrics();
      int charw = 0;
      int lineStartOffset = 0;
      boolean isTrimNeeded = false;
      for (int step = 0; step < this.lengthChars; step++) {
         charw = sm.getCharWidth(step);
         lineWidth += charw;
         if (lineWidth > width) {
            if (lineCount == maxLines) {
               //we reached the end of available lines. trim the last 2 characters to replace them with the trim cue.
               lineWidth -= charw;
               isTrimNeeded = true;
               break;//end the algo
            } else {
               //special case where not even one character can fit the space. only one dot will be drawn.
               if (numCharOnLine == 0) {
                  numCharOnLine = 1;
                  lineWidth = 1;
                  isTrimNeeded = true;
                  break;
               } else {
                  //finish current line
                  data.addInt(lineStartOffset);
                  data.addInt(numCharOnLine);
                  data.addInt(lineWidth - charw);
                  lineStartOffset = step;
                  lineCount++;
                  lineWidth = charw;
                  numCharOnLine = 1;
               }
            }
         } else {
            //increment the number of characters on this line
            numCharOnLine += 1;
         }
      }
      //finalize line if there is enough space
      data.addInt(lineStartOffset);
      data.addInt(numCharOnLine);
      data.addInt(lineWidth);
      int flag = 0;
      if (!isTrimNeeded) {
         flag = 1;
      }
      data.addInt(flag);
      return data.getIntsRef();
   }

   /**
    * Method creates a trim cue with {@link Stringer} and the given width.
    * <br>
    * <br>
    * 
    * POST: the state of {@link Stringer} is not modified.
    * <br>
    * <br>
    * @param str
    * @return null if trimming is not needed. For structure semantics see {@link StringMetrics#breaks}
    */
   public int[] getTrimSingleLine(int width) {
      StringMetrics sm = this.getMetrics();
      int widthPixelCount = 0;
      boolean isTrimmed = false;
      IntBuffer breaks = new IntBuffer(drc.getUCtx());
      int numCharOnLine = 0;
      int charw = 0;
      int stepStart = 0;
      int stepEnd = this.lengthChars;
      for (int step = stepStart; step < stepEnd; step++) {
         charw = sm.getCharWidth(step);
         widthPixelCount += charw;
         if (widthPixelCount <= width) {
            numCharOnLine++;
         } else {
            widthPixelCount -= charw;
            isTrimmed = true;
            break;
         }
      }
      if (isTrimmed) {
         //finalize line.
         breaks.addInt(stepStart);
         breaks.addInt(numCharOnLine);
         breaks.addInt(widthPixelCount);
         breaks.addInt(0);
         return breaks.getIntsRef();
      } else {
         return null;
      }
   }

   /**
    * 
    * @param lineIndex
    * @return
    */
   public int[] getWordBreaks(int lineIndex) {
      if (stringMetrics.lineWordBreaks != null) {
         return stringMetrics.lineWordBreaks[lineIndex];
      }
      return null;
   }

   public boolean hasState(int state) {
      return BitUtils.hasFlag(states, state);
   }

   public void initFig(ByteObject textFigure, char[] chars, int offset, int len) {
      textFigure.checkType(TYPE_050_FIGURE);

      this.charsBackup = null;
      if (chars == null) {
         throw new NullPointerException();
      }
      this.charsBackup = chars;
      this.offsetChars = offset;
      this.lengthChars = len;
      this.text = textFigure;
      if (text.hasFlag(FIG__OFFSET_02_FLAG, FIG_FLAG_1_ANCHOR)) {
         anchor = text.getSubFirst(TYPE_069_ANCHOR);
      }
      if (text.hasFlag(FIG__OFFSET_02_FLAG, FIG_FLAG_4_MASK)) {
         //figure has a mask, move it to text mask fx.
      }
      resetState();
      stringMetrics.reset();

      intervalOfStringLeaves.clear();

      //all txt effect are stored sequencially
      //no effects. we extract figure information from text to create the StringFx object.
      stringFx.initFigure(textFigure);
      ByteObject[] subs = textFigure.getSubs(TYPE_070_TEXT_EFFECTS);
      if (subs != null && subs.length != 0) {
         initTextEffects(textFigure, subs);
      }
   }

   public void initFig(ByteObject textFigure, String str) {
      this.initFig(textFigure, str.toCharArray(), 0, str.length());
   }

   private void initMetrics() {
      stringMetrics.reset();
   }

   /**
    * {@link IBOFxStr}
    * scope?
    */
   private ByteObject   boFxRoot;

   private StringLeaf[] leaves = new StringLeaf[4];

   /**
    * Building is done before string breaking..
    * 
    * TODO When big blobs of text, we can't put everything into memory.
    * So wrapper around Stringer only feeds portion of the text
    * When style is changed for some leaves, the cached computed widths are cleared.
    * TODO monospace optimization
    */
   public void buildStringLeaves() {

      //todo optimized drawing by drawing all leaves with same FX in one pass
      //that will depends on the fx.. complex fx might depends on letter flow

      //string leaf is initialized with base StringFx
      //and encompasses the whole area.
      //we use start end buffered structure for building leaves
      StringLeaf leaf = new StringLeaf(drc, this, boFxRoot);
      //TODO if boFxRoot declares index based styling? we need to create intervals for it before.

      //index based style create a layer style on top that is 

      //base fx
      StringFx rootFx = stringFx;
      //may generate different leaves
      leaf.setByteObjectFx(rootFx);

      IntIntervals intervalOfStringLeaves = new IntIntervals(drc.getUCtx());
      intervalOfStringLeaves.setPayLoadCheck(true);

      IntInterval rootInterval = intervalOfStringLeaves.addInterval(0, lengthChars);
      rootInterval.setPayload(leaf);

      //scope to scope.. a charFx will inherit the lineFx
      //how do you deal with lineFx mixing with charFx/wordFx
      //rootfx says lines have a color function.. for bg and fg.
      //what happens when charFx specific in middle of a line?

      //apply first interval of first enumeration
      //each layer splits the leaves IntIntervals further and further, 
      //each time merging the ByteObject style with the IntInterval payload fx.
      for (int i = 0; i < styleLayers.length; i++) {
         StringLayerStyle layer = styleLayers[i];
         Enumeration layerIntervals = layer.getIntervals();
         while (layerIntervals.hasMoreElements()) {
            IntInterval intervalWithStyle = (IntInterval) layerIntervals.nextElement();
            leaf.setOffset(intervalWithStyle.getOffset());
            leaf.setLen(intervalWithStyle.getLen());

            ByteObject boFxTop = (ByteObject) intervalWithStyle.getPayload();
            //#debug
            drc.toStringCheckNull(boFxTop);

            //look below this interval and create leaves
            IntInterval[] intersect = intervalOfStringLeaves.getIntersection(intervalWithStyle);

            //if no leaves under it.. use root leave for constructing the style
            for (int j = 0; j < intersect.length; j++) {
               IntInterval intervalBelowStringLeaves = intersect[i];
               StringLeaf leafBelow = (StringLeaf) intervalBelowStringLeaves.getPayload();
               ByteObject boFxBelow = leafBelow.getBoFx();
               //optimize to reuse existing merges
               ByteObject boFxMerged = fxCache.getFxCacheMerge(boFxBelow, boFxTop);

               IntInterval newi = intervalWithStyle.createFromIntersectionWith(intervalBelowStringLeaves);
               StringLeaf leafNew = new StringLeaf(drc, this, boFxMerged);
               newi.setPayload(leafNew);
               intervalOfStringLeaves.addInterval(newi);
            }
         }
      }

      Enumeration leafIntervals = intervalOfStringLeaves.getIntervalEnumeration();
      while (leafIntervals.hasMoreElements()) {
         //construct the fx
         IntInterval ii = (IntInterval) leafIntervals.nextElement();
         StringLeaf boFxTop = (StringLeaf) ii.getPayload();

         //compute stringfx and charwidth?
      }
   }

   /**
    * Build from scratch
    * 
    * When adding characters, we may take existing {@link IntIntervals} and modify it
    * @param intIntervals
    */
   public IntIntervals buildIntervalWords() {
      IntIntervals intIntervals = new IntIntervals(drc.getUCtx());
      char[] ar = charsBackup;
      int currentLen = 0;
      int currentOffset = 0;
      boolean inWord = false;
      char[] seps = drc.getConfigDrawX().getWordSeparators();
      for (int i = offsetChars; i < lengthChars; i++) {
         char c = ar[i];
         if (CharUtils.contains(seps, c)) {
            if (inWord) {
               //finish the previous interval
               IntInterval ii = new IntInterval(drc.getUCtx(), currentOffset, currentLen);
               intIntervals.addInterval(ii);
               inWord = false;
               currentLen = 0;
            }
         } else {
            if (inWord) {
               currentLen++;
            } else {
               currentOffset = i;
               currentLen = 1;
            }
         }
      }
      if(currentLen != 0) {
         IntInterval ii = new IntInterval(drc.getUCtx(), currentOffset, currentLen);
         intIntervals.addInterval(ii);
      }
      return intIntervals;
   }

   /**
    * Computed when {@link Stringer} needs to apply fx scoped to words
    */
   private IntIntervals intervalOfWords;

   private IntIntervals intervalOfStringLeaves;

   private FxCache      fxCache;

   
   public void removeFxs() {
      
   }
   
   /**
    * Adds the fx over the whole text 
    * or
    * Reset 
    * TODO only one fx over the whole text.
    * what we ant to add if index based byteobject.. that transforms
    * when conflict? order first
    * if not, it will merge with stack of fx 
    * 
    * dynamic effect are set using a {@link StringLayerStyle}
    * @param fx
    */
   public void addFx(ByteObject fx) {
      //#debug
      fx.checkType(IBOTypesDrw.TYPE_070_TEXT_EFFECTS);
      
      
   }
   /**
    * Reads the different {@link IBOFxStr} definitions and sort them.
    * @param textFigure
    * @param subs not null by contract size above 0 and elements inside are not null
    * a set of {@link IBOFxStr} that may be referenced by ID.
    * When one defines intervals for their scope, a {@link StringLayerStyle} is generated
    * just for it.
    */
   public void initTextEffects(ByteObject textFigure, ByteObject[] subs) {
      setState(ITechStringer.STATE_08_ACTIVE_STYLE, true);
      int dsize = getNumDynamic(textFigure);
      if (dsize > 0) {
         fxsDynamicDefinition = new ByteObject[dsize + 1];
         intervals = new StringInterval[1 + dsize];
      }
      int numIndexStatic = getNumStaticIndex(subs);
      fxsStatic = new StringFx[subs.length - dsize - numIndexStatic];
      fxsStaticIndex = new StringFx[numIndexStatic];
      int countDynamic = 1;
      int countStatic = 0;
      int countStaticIndex = 0;
      for (int i = 0; i < subs.length; i++) {
         ByteObject textEffectBO = subs[i];
         if (textEffectBO != null) {

            StringFx fxi = new StringFx(drc, this);
            fxi.init(textEffectBO);
            if (textEffectBO.hasFlag(FX_OFFSET_02_FLAGX, FX_FLAGX_2_DYNAMIC)) {
               fxsDynamicDefinition[countDynamic] = textEffectBO;
               countDynamic++;
            } else {
               if (textEffectBO.hasFlag(FX_OFFSET_02_FLAGX, FX_FLAGX_6_DEFINED_INDEX)) {
                  fxsStaticIndex[countStaticIndex] = fxi;
                  countStaticIndex++;
               } else {
                  fxsStatic[countStatic] = fxi;
                  countStatic++;
               }
            }
         }
      }
      //create the static final style that by default applies to all chars
      for (int i = 0; i < fxsStatic.length; i++) {
         stringFx = stringFx.add(fxsStatic[i]);
      }
      //create the index
      for (int i = 0; i < fxsStaticIndex.length; i++) {
         int scope = fxsStaticIndex[i].fxDefinition.get1(FX_OFFSET_04_TYPE_SCOPE1);
         int index = fxsStaticIndex[i].fxDefinition.get2(FX_OFFSET_04_INDEX2);

         if (scope == FX_SCOPE_0_CHAR) {
            if (charFxs == null) {
               charFxs = new StringFx[lengthChars];
            }
            //check index pattern? what if part of
            charFxs[index] = stringFx.cloneMerge(fxsStaticIndex[i]);

         } else if (scope == FX_SCOPE_1_WORD) {

         } else if (scope == FX_SCOPE_2_LINE) {
            if (lineFxs == null) {
               lineFxs = new StringFx[getNumOfLines()];
            }

         }
      }
      if (countStaticIndex != 0) {
         setState(ITechStringer.STATE_16_STATIC_INDEX_FX, true);
      }
      if (countDynamic == 0) {
         setState(ITechStringer.STATE_10_ACTIVE_DYNAMIC_STYLE, false);
      }
      if (countStatic != 0) {
         setState(ITechStringer.STATE_13_FX, true);
      }
      //from the definitions
      setActiveFXs();
   }

   /**
    * Default metering using parameters set by 
    * 
    * <li> {@link Stringer#setBreakType(int)}
    * <li> {@link Stringer#setBreakWH(int, int)}
    * <li> {@link Stringer#setBreakMaxLines(int)}
    */
   public void meterString() {
      this.meterString(breakW, breakH, breakType, breakMaxLines);
   }

   /**
    * Break the String using areaW and areaH.
    * <br>
    * <br>
    * 
    * @param breakType {@link ITechStringDrw#BREAK_4_TRIM_SINGLE_LINE} etc.
    * @param maxLines
    */
   public void meterString(int breakType, int maxLines) {
      this.meterString(areaW, areaH, breakType, maxLines);
   }

   /**
    * Meters the string size and break it to fit the break area and break type.
    * <br>
    * <br>
    * @param breakWidth
    * @param breakHeight
    * @param breakType {@link ITechStringDrw#BREAK_4_TRIM_SINGLE_LINE} etc.
    * @param maxLines
    */
   public void meterString(int breakWidth, int breakHeight, int breakType, int maxLines) {
      checkStateRun();
      getMetrics().breakStringEntry(breakType, maxLines, breakWidth, breakHeight);
      //decide type
      boolean isFX = hasState(ITechStringer.STATE_08_ACTIVE_STYLE);
      if (stringMetrics.breaks != null) {
         if (isFX) {
            drawLineType = ITechStringer.TYPE_3_BREAKS_FX;
         } else {
            drawLineType = ITechStringer.TYPE_2_BREAKS;
         }
      } else {
         if (isFX) {
            drawLineType = ITechStringer.TYPE_1_SINGLE_LINE_FX;
         } else {
            drawLineType = ITechStringer.TYPE_0_SINGLE_LINE;
         }
      }
   }

   public void newLine() {
      areaY += stringMetrics.getLineHeight();
      stringDraw.init(0, areaY);
   }

   public void resetState() {
      states = 0;
   }

   /**
    * From the definitions, create the {@link Stringer#charFxs} if necessary.
    * <br>
    * <br>
    * 
    */
   private void setActiveFXs() {
      boolean isGranular = false;
      for (int i = 0; i < fxsStatic.length; i++) {
         StringFx fx = fxsStatic[i];
         if (fx.fxDefinition.hasFlag(FX_OFFSET_02_FLAGX, FX_FLAGX_6_DEFINED_INDEX)) {
            isGranular = true;
         }
      }
      if (isGranular) {
         charFxs = new StringFx[lengthChars];
      }
   }

   /**
    * Externally set anchor?
    * <br>
    * <br>
    * Well yes, {@link StringDrawable} style decides anchoring independantly of the String figure.
    * <br>
    * <br>
    * 
    * @param anchor
    */
   public void setAnchor(ByteObject anchor) {
      this.anchor = anchor;
   }

   public void setAreaWH(int contentW, int contentH) {
      areaW = contentW;
      areaH = contentH;
   }

   /**
    * Sets the area.. used for computing alignments
    * 
    * Breaking?
    * @param x
    * @param y
    * @param contentW
    * @param contentH
    */
   public void setAreaXYWH(int x, int y, int contentW, int contentH) {
      areaX = x;
      areaY = y;
      areaW = contentW;
      areaH = contentH;

      stringDraw.init(areaX, areaY);
   }

   public void setBreakMaxLines(int breakMaxLines) {
      this.breakMaxLines = breakMaxLines;
   }

   //#mdebug

   public void setBreakOnArea() {
      breakW = areaW - areaX;
      breakH = areaH - areaY;
   }

   /**
    * <li> {@link ITechStringDrw#BREAK_0_NONE}
    * <li> {@link ITechStringDrw#BREAK_1_WIDTH}
    * <li> {@link ITechStringDrw#BREAK_2_NATURAL}
    * <li> {@link ITechStringDrw#BREAK_3_ONE_LINE}
    * @param breakType
    */
   public void setBreakType(int breakType) {
      this.breakType = breakType;
   }

   /**
    * When 0, areaW / areaH will be used
    * @param breakW
    * @param breakH
    */
   public void setBreakWH(int breakW, int breakH) {
      this.breakW = breakW;
      this.breakH = breakH;
   }

   public void setBreakWidth(int breakW) {
      this.breakW = breakW;
   }

   public void setCharAt(int i, char c) {
      stringMetrics.setCharAt(i, c);
   }

   /**
    * 
    * @param i
    * @param c
    */
   public void setCharAtRelative(int indexRel, char c) {
      chars[offsetChars + indexRel] = c;
   }

   public void setChars(char[] chars, int offset, int len) {
      this.chars = chars;
      this.offsetChars = offset;
      this.lengthChars = len;
   }

   /**
    * Moi j'ai pas beaucoup de dÃ©penses physiques mais je dors bien ðŸ™‚
    * ðŸ˜• ðŸ˜© ðŸ˜© pas assez de depense d'energies physiques
    * ca va? ðŸ˜˜ â˜” â˜€ â™  â™¡ â™¢ â™£ â™¤ â™¥ â™¦ â™§
    */
   private void setDynamicFXs() {
   }

   /**
    * Overwrites the interval in the chosen layer
    * @param offset
    * @param len
    * @param layerID
    * @param styleID
    * @return
    */
   public IntInterval addInterval(int offset, int len, int layerID, ByteObject fx) {
      StringLayerStyle layer = getLayer(layerID);
      IntInterval ii = layer.addInterval(offset, len, fx);
      return ii;
   }

   /**
    * {@link StringLayerStyle} on which you can set new intervals.
    * 
    * @param layerID 0 for base style layer, 1 for selection layer etc
    * @return
    */
   public StringLayerStyle getLayer(int layerID) {
      return styleLayers[layerID];
   }

   public void setPosition(int contentX, int contentY) {
      areaX = contentX;
      areaY = contentY;
      stringDraw.init(areaX, areaY);
   }

   void setState(int state, boolean v) {
      states = BitUtils.setFlag(states, state, v);
   }

   public void setString(String str) {
      char[] charArray = str.toCharArray();
      this.setChars(charArray, 0, charArray.length);
   }

   public void selectInterval(int id) {

   }

   /**
    * Sets the {@link Stringer} with new text figure.
    * 
    * @param textFigure
    */
   public void setTextFigure(ByteObject textFigure) {
      //#debug
      textFigure.checkType(TYPE_050_FIGURE);

      resetState();

      this.text = textFigure;
      if (text.hasFlag(FIG__OFFSET_02_FLAG, FIG_FLAG_1_ANCHOR)) {
         anchor = text.getSubFirst(TYPE_069_ANCHOR);
      }
      if (text.hasFlag(FIG__OFFSET_02_FLAG, FIG_FLAG_4_MASK)) {
         //figure has a mask, move it to text mask fx.

      }
      stringFx.initFigure(textFigure);

      ByteObject[] subs = textFigure.getSubs(TYPE_070_TEXT_EFFECTS);
      if (subs != null && subs.length != 0) {
         initTextEffects(textFigure, subs);
      }

      stringMetrics.reset();
   }

   /**
    * TODO relation with state style update modifying structure? Is it acceptable?
    * <br>
    * Sometimes we want the update to change the structure.
    * For simple state change to BOLD, we do not want this.
    * <br>
    * Somehow {@link Stringer} must find out if different style change computed metrics.
    * <li>Check Font
    * <li>Check Fx
    * <br>
    * <br>
    * @param text
    * @param x
    * @param y
    * @param w
    * @param h
    */
   public void setTextObjectArea(ByteObject text, int x, int y, int w, int h) {
      if (this.text != text) {
         this.text = text;
         stringFx.init(text);
      }
   }

   public void toString(Dctx dc) {
      dc.root(this, Stringer.class, 980);
      dc.appendWithSpace("(" + offsetChars + "," + lengthChars + ") ");
      super.toString(dc.sup());

      if (chars == null) {
         chars = "STRINGER NULL CHAR[]".toCharArray();
         offsetChars = 0;
         lengthChars = chars.length;
      }
      String strDis = getDisplayedString();
      dc.append("DisplayedString ->");
      dc.append(strDis);
      dc.append("<-");

      dc.nlLvl(text, "textFigure");

      IMFont stringFont = this.drc.getFxStringOperator().getStringFont(text);

      dc.setFlagData(drc.getCoreDrawCtx(), IFlagToStringCoreDraw.TOSTRING_FLAG_3_IGNORE_FONT_ATTRIBUTES, true);
      dc.setFlagData(drc.getCoreDrawCtx(), IFlagToStringCoreDraw.TOSTRING_FLAG_4_SHOW_FONT_ENVIRONEMT, false);
      dc.nlLvl(stringFont, "stringFont");

      dc.nl();
      dc.append("Area = " + areaX + "," + areaY + " " + areaW + "," + areaH);
      dc.appendVarWithSpace("type", ToStringStaticDrawx.stringerType(drawLineType));
      dc.appendVarWithSpace("getLen()", getLen());
      dc.nl();
      dc.append("States ->");
      IntToStrings stateFlags = ToStringStaticDrawx.stringerStateFlagMap(toStringGetUCtx());
      dc.appendFlagsPositive(states, "States ->", stateFlags);
      dc.nl();
      dc.appendFlagsNegative(states, "States ->", stateFlags);

      dc.nlLvlArray("StaticFxs", fxsStatic);
      dc.nlLvlArray("Intervals", intervals);

      dc.nlLvl(anchor);

      dc.nlLvl(stringMetrics);
      dc.nlLvl(stringDraw);
      dc.nlLvl(stringFx);

   }

   public void toString1Line(Dctx dc) {
      dc.root1Line(this, "Stringer");
   }

   public boolean ToStringIsDebugArea() {
      return toStringDebugArea;
   }

   public void ToStringSetDebugArea(boolean toStringDebugArea) {
      this.toStringDebugArea = toStringDebugArea;
   }
   //#enddebug

   public StringLayerStyle createLayer(String string) {
      StringLayerStyle sls = new StringLayerStyle(drc, this);
      return sls;
   }

}
